REM /**
REM  * TaskApp.bbj
REM  * @author gosteen, ndecker
REM  *
REM  */
REM package TaskApp


declare auto TaskApp app!
app! = new TaskApp()
app!.run()
end


REM /**
REM  * A DWC-specific task manager BBj program.
REM  *
REM  * The TaskApp program was designed to a be part of a tutorial series that covers
REM  * how to write a graphical web-based application in BBj. It's designed to run
REM  * in the BASIS Dynamic Web Client (DWC), and takes advantage of several DWC
REM  * features including light/dark theme support, responsive design, and making
REM  * use of 3rd-party web components.
REM  */
class public TaskApp

    REM Protected Fields
    REM ========================================
    field protected BBjSysGui           sysgui!
    field protected BBjWebManager       webManager!
    field protected BBjTopLevelWindow   winMain!
    field protected TaskProperties      taskProperties!
    field protected Settings            settings!
    field protected TaskCardView        taskCardView! = new TaskCardView()
    field protected BBjChildWindow      winNavBar!
    field protected BBjChildWindow      winToolBar!
    field protected BBjChildWindow      winTitle!
    field protected BBjChildWindow      winViews!
    field protected BBjChildWindow      winTaskCard!
    field protected BBjChildWindow      winTaskCardIncomplete!
    field protected BBjChildWindow      winTaskCardComplete!
    field protected BBjChildWindow      winTaskCardPriority!
    field protected BBjChildWindow      winTaskCardDueDate!
    field protected BBjChildWindow      winTasks!
    field protected BBjStaticText       labelDay!
    field protected BBjStaticText       labelDate!
    field protected BBjVector           vectTaskLists! = BBjAPI().makeVector()

    REM NavBar and ToolBar controls
    field protected BBjButton           btnAddTaskFAB!
    field protected BBjListButton       lstFontFamily!
    field protected BBjRadioButton      switchLayout!

    REM Misc Data
    field protected BBjString           appName! = "TaskApp"
    field protected BBjString           version! = "0.07"
    field protected BBjString           appPath! = dsk("") + dir("")
    field protected BBjVector           vectFontFamilies! = BBjAPI().makeVector()
    field public    BBjString           taskView! = "incomplete"
    field public    BBjChildWindow      winTaskCardView!
    field public    BBjButton           btnIncompleteView!
    field public    BBjButton           btnCompleteView!
    field public    BBjButton           btnPriorityView!
    field public    BBjButton           btnDueView!
    field public    BBjNumber           displayType! = 2

    REM Some sort of list of tasks.
    REM ========================================
    REM It could be a BBjVector or BBjArray of tasks.
    REM It could also be a Java Collection class like:
    REM     Set     https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Set.html
    REM     List    https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html
    REM     Map     https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html
    REM /**
    REM  * A collection of Task objects in a Java TreeMap
    REM  * Key:   UUID of the Task
    REM  * Value: Task object
    REM  * @see <a href='https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/TreeMap.html' target='_blank'>TreeMap</a> documentation
    REM  */
    field protected TreeMap tasks!
    field protected TreeMap taskViews!
    field protected TreeMap taskPriorityViews!
    field protected TreeMap taskDueDateViews!

    REM Constants
    REM ========================================
    REM /** A constant value that's used to set the TaskApp's theme to the DWC's light theme */
    method public static BBjString THEME_LIGHT()
        methodret "light"
    methodend
    REM /** A constant value that's used to set the TaskApp's theme to the DWC's dark theme */
    method public static BBjString THEME_DARK()
        methodret "dark"
    methodend
    REM /** A constant value that's used to set the TaskApp's theme to the DWC's system theme,
    REM  * meaning that it follows the operating system's configuration.  For example, when the
    REM  * user's device switches to its dark theme, then the app will also switch its theme
    REM  * to the DWC's dark theme. */
    method public static BBjString THEME_SYSTEM()
        methodret "system"
    methodend

    REM Define the user preferences which will be stored in a HashMap and saved out as a cookie
    REM ========================================
    REM /** The hashmap that stores all the user's preferences */
    field private HashMap hashPrefs!
    REM /** The user's preferred DWC theme to use for the UI, i.e. light, dark, dark-pure, or system */
    field protected BBjString prefsTheme! = #THEME_SYSTEM()
    REM /** The user's preferred font family (CSS: font-family)for the tasks */
    field protected BBjString prefsTaskFontFamily! = "Rambla"
    REM /** The user's preferred font weight (CSS: font-weight)for the tasks */
    field protected BBjString prefsTaskFontWeight! = "var(--dwc-font-weight-semibold)"
    REM /** The user's preferred font size for the tasks.
    field protected BBjString prefsTaskFontSize! = "var(--dwc-font-size-m)"
    REM /** The user's preferred font letter spacing (CSS: letter-spacing) for the tasks.  This will usually be 'normal', but can be a length as in '0.5px'. */
    field protected BBjString prefsTaskFontSpacing! = "normal"
    REM /** The user's preferred font weight for the tasks */
    field protected BBjNumber prefsDefaultTaskPriority! = 3
    REM /** The TaskApp's version, used for display purposes only */
    field protected BBjString prefsVersion! = #version!


    REM Constructors
    REM ========================================
    method public TaskApp()
        REM Instatiate the WebManager and use it to inject the app's CSS
        #webManager! = BBjAPI().getWebManager()
        css! = java.nio.file.Files.readAllBytes(java.nio.file.Path.of(#appPath!+"TaskApp.css"))
        #webManager!.injectStyle(css!, 0, "name=taskapp_css")
        css! = java.nio.file.Files.readAllBytes(java.nio.file.Path.of(#appPath!+"taskView.css"))
        #webManager!.injectStyle(css!, 0, "name=taskapp_taskview_css")
        css! = java.nio.file.Files.readAllBytes(java.nio.file.Path.of(#appPath!+"taskListView.css"))
        #webManager!.injectStyle(css!, 0, "name=taskapp_list_view_css")
        css! = java.nio.file.Files.readAllBytes(java.nio.file.Path.of(#appPath!+"taskCardView.css"))
        #webManager!.injectStyle(css!, 0, "name=taskapp_card_view_css")
        css! = java.nio.file.Files.readAllBytes(java.nio.file.Path.of(#appPath!+"Settings.css"))
        #webManager!.injectStyle(css!, 0, "name=taskapp_settings_css")
        REM ' set legacy BBj className values when running in DWC.
        if info(3,6)="6" then
            bbjapi().getWebManager().setAttribute("dwc.class","true")
        endif

        REM Set the app's icon in the browser's tab
        url! = "https://public.basis.cloud/images/DWCTaskApp.svg"
        attrib! = "rel=icon,type=image/svg,id=dwc_taskapp_icon"
        #webManager!.injectLinkUrl(url!, 1, attrib!, err=*NEXT)

        REM Inject links for a number of custom Google fonts
        fontFamily! = "?family=Asap&family=Bebas+Neue&family=Fira+Sans&family=Fredoka:wght@300..700&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&family=Marcellus+SC&family=Marko+One&family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&family=Oswald:wght@200..700&family=Rambla:ital,wght@0,400;0,700;1,400;1,700&family=Signika:wght@300;400&family=Teko:wght@300..700&family=Ubuntu&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Work+Sans"
        fontFamily! = fontFamily! + "&family=K2D:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800"
        #webManager!.injectLinkUrl("https://fonts.googleapis.com", 1, "rel=preconnect")
        #webManager!.injectLinkUrl("https://fonts.gstatic.com", 1, "crossorigin")
        #webManager!.injectLinkUrl("https://fonts.googleapis.com/css2?" + fontFamily!, 1, "rel=stylesheet,display=swap")

        REM Create a list of font families filled with Google fonts that the user will be able to choose from to style the tasks
        DATA "Marcellus SC", "Marko One", "Merriweather", "Oswald", "Rambla", "Signika", "Teko", "Ubuntu", "Ubuntu Mono", "Work Sans", "Asap", "K2D", "Bebas Neue", "Fira Sans", "Fredoka",  "Lato"
        while 1
            DREAD family$,err=*BREAK
            #vectFontFamilies!.addItem(family$)
        wend
        REM Sort the vector of fonts alphabetically by name
        java.util.Collections.sort(#vectFontFamilies!)

        REM Create the collection for the tasks
        #tasks! = new TreeMap()
        #taskViews! = new TreeMap()
        #taskPriorityViews! = new TreeMap()
        #taskDueDateViews! = new TreeMap()

        REM Create the HashMap to store the user preferences and load it up with the default values
        #hashPrefs! = new HashMap()
        #hashPrefs!.put("prefsTheme", #prefsTheme!)
        #hashPrefs!.put("prefsTaskFontFamily", #prefsTaskFontFamily!)
        #hashPrefs!.put("prefsTaskFontWeight", #prefsTaskFontWeight!)
        #hashPrefs!.put("prefsTaskFontSize", #prefsTaskFontSize!)
        #hashPrefs!.put("prefsTaskFontSpacing", #prefsTaskFontSpacing!)
        #hashPrefs!.put("prefsDefaultTaskPriority", #prefsDefaultTaskPriority!)
        #hashPrefs!.put("prefsVersion", #prefsVersion!)


        REM Read the user's preferences from a cookie, then apply all saved values to the HashMap of user preferences
        REM This means that the HashMap is initially filled with default values, but then the user's saved preferences replace the defaults
        hashPrefsFromCookie! = #getCookies(#appName!,err=*NEXT)
        if (hashPrefsFromCookie! <> null()) then
            it! = hashPrefsFromCookie!.keySet().iterator()
            while (it!.hasNext())
                key! = it!.next()
                if (#hashPrefs!.containsKey(key!)) then
                    value! = hashPrefsFromCookie!.get(key!)
                    #hashPrefs!.put(key!, str(value!))
                endif
            wend
        endif

        REM Get the updated preferences from the HashMap and apply the values to our field variables
        #prefsTheme! = #hashPrefs!.get("prefsTheme").toString()
        #prefsTaskFontFamily! = #hashPrefs!.get("prefsTaskFontFamily").toString()
        #prefsTaskFontWeight! = #hashPrefs!.get("prefsTaskFontWeight").toString()
        #prefsTaskFontSize! = #hashPrefs!.get("prefsTaskFontSize").toString()
        #prefsTaskFontSpacing! = #hashPrefs!.get("prefsTaskFontSpacing").toString()
        #prefsDefaultTaskPriority! = num(#hashPrefs!.get("prefsDefaultTaskPriority"))

        REM Finally, apply user preferences
        #webManager!.setTheme(#prefsTheme!, err=*NEXT)
        #setCssProperty("--app-font-family-task", #prefsTaskFontFamily!)
        #setCssProperty("--app-font-weight-task", #prefsTaskFontWeight!)
        #setCssProperty("--app-font-size-task", #prefsTaskFontSize!)
        #setCssProperty("--app-font-spacing-task", #prefsTaskFontSpacing!)

        REM Register for a custom event that the TaskProperties fires after the user is done editing or adding a task
        BBjAPI().setCustomEventCallback("TASK_UPDATE",#this!,"onTaskUpdate")
    methodend


    REM Methods
    REM ========================================
    REM /**
    REM  * Runs the TaskApp application
    REM  */
    method public void run()
        if (new java.io.File(#appPath!+"tasks.json").exists()) then
            #onImport(null(), err=*next)
        else
            #createSampleTasks(50)
        endif

        if (#tasks!.size() = 0)
            #createSampleTasks(50)
        endif

        REM Create the UI and display the tasks
        #sysgui! = BBjAPI().openSysGui("X0")
        #createMainWindow()
        process_events
    methodend

    REM /**
    REM  * Create the main window for the application
    REM  */
    method public void createMainWindow()
        #winMain! = #sysgui!.addWindow("TaskApp", $011C1091$)
        #winMain!.addClass("winMain")
        #winMain!.setIcon(#appPath!+"images/DWCTaskApp.png")

        REM Create the child windows
        #winNavBar! = #winMain!.addChildWindow("NavBar", $00108800$, #sysgui!.getAvailableContext())
        #winNavBar!.addClass("winNavBar")

        REM Determine the user's name and initials for the profile display in the NavBar
        userName! = System.getProperty("com.basis.jetty.company_name")
        if (userName! = null()) then userName! = "Guest User"
        userInitials! = userName!.toUpperCase().substring(0,2)
        lblUserName! = #winNavBar!.addStaticText(userName!)
        lblUserName!.addClass("nav_item nav_user_name")
        #webManager!.injectStyle(".nav_item.nav_user_name::before { content: '" + userInitials! + "';")

        REM Create a linefeed-delimited list of font families from the vectory to populate the BBjListButton
        fontFamiliesList! = java.lang.String.join($0a$, java.util.Arrays.asList(#vectFontFamilies!))
        REM Modfify each entry in the list so that use uses HTML markup to style the font name to that font family
        regExSearchFor! = "(?mi)^(.*)$"
        regExReplaceWith! = "<html><span style='font-family:$1;font-weight:var(--app-font-weight-task);font-size:var(--app-font-size-task);letter-spacing:var(--app-font-spacing-task);'>$1</span>"
        fontFamiliesList! = fontFamiliesList!.replaceAll(regExSearchFor!, regExReplaceWith!)

        REM Add the font family listbutton, add some custom classes, and set the callback
        #lstFontFamily! = #winNavBar!.addListButton(fontFamiliesList!)
        #lstFontFamily!.setAttribute("button-height", "2.25em")
        #lstFontFamily!.setAttribute("label", "Font Family")
        #lstFontFamily!.setAttribute("open-height", "100%")
        #lstFontFamily!.addClass("nav_item nav_fonts")
        #lstFontFamily!.setCallback(BBjControl.ON_LIST_CHANGE, #this!, "onListChangeFontFamilies")

        REM Select the correct font family for the tasks in the BBjListButton
        if (#vectFontFamilies!.contains(#prefsTaskFontFamily!)) then
            REM Select the user's preferred font family in the list
            #lstFontFamily!.selectIndex(#vectFontFamilies!.indexOf(#prefsTaskFontFamily!))
        else
            REM Since the user's preferred font family for the tasks wasn't in the vector, we'll default to the first item in the list
            #lstFontFamily!.selectIndex(0)
            #setCssProperty("--app-font-task", str(#vectFontFamilies!.getItem(0)))
        endif

        #switchLayout! = #winNavBar!.addRadioButton("Layout Type")
        #switchLayout!.addClass("switchLayout")
        #switchLayout!.setAttribute("switch", "")
        #switchLayout!.setAttribute("expanse", "m")
        #switchLayout!.setCallback(BBjControl.ON_CHECK_CHANGE, #this!, "OnSwitchChangeLayout")

        #winToolBar! = #createWinToolBar()
        #winTitle! = #createWinTitle()


        REM TASK LIST VIEW: main window
        #winTasks! = #winMain!.addChildWindow("Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTasks!.addClass("winTasks listLayout")

        REM TASK CARD VIEW: main window
        #winTaskCardView! = #winMain!.addChildWindow("Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTaskCardView!.addClass("winTaskCardView")
        #winTaskCardView!.setVisible(0)

        #winTaskCard! = #winTaskCardView!.addChildWindow("All Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTaskCard!.addClass("winCardTasks")
        #winTaskCardComplete! = #winTaskCardView!.addChildWindow("Completed Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTaskCardComplete!.addClass("winCardTasks")
        #winTaskCardComplete!.setVisible(0)

        #addTaskList("default")

        REM TASK CARD VIEW: buttons
REM         #winViews! = #winTitle!.addChildWindow("Title", $00108800$, #sysgui!.getAvailableContext())
REM         #winViews!.addClass("winViews")

REM         #btnIncompleteView! = #winViews!.addButton("Incomplete")
REM         #btnIncompleteView!.addClass("btnView")
REM         #btnIncompleteView!.addClass("view-btn-selected")
REM         #btnPriorityView! = #winViews!.addButton("Priority Level")
REM         #btnPriorityView!.addClass("btnView")
REM         #btnDueView! = #winViews!.addButton("Due Date")
REM         #btnDueView!.addClass("btnView")
REM
REM         #btnIncompleteView!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onIncompleteView")
REM         #btnPriorityView!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onPriorityView")
REM         #btnDueView!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onDueView")

        REM Create the FAB (floating action button) and the toolbar buttons
        #btnAddTaskFAB! = #winMain!.addButton("<html><dwc-icon pool='tabler' name='plus'></dwc-icon>")
        #btnAddTaskFAB!.addClass("btnAddTaskFAB")
        #btnAddTaskFAB!.setAttribute("theme", "primary")
        #btnAddTaskFAB!.setAttribute("expanse", "xs")
        #btnAddTaskFAB!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onAddTask")

        #displayTasks()
        #winMain!.setVisible(1)
    methodend
    
    REM /**
    REM  * Creates the winTitle window with the date and day labels.
    REM  * @return The BBjChildWindow that holds the title elements. 
    REM  */
    method public BBjChildWindow createWinTitle()
        winTitle! = #winMain!.addChildWindow("Title", $00108800$, #sysgui!.getAvailableContext())
        winTitle!.addClass("winTitle")
        #labelDay! = winTitle!.addStaticText("Today", $4000$)
        #labelDay!.addClass("labelDay")
        #labelDate! = winTitle!.addStaticText(date(0:"%Dl, %Ml %D"), $4000$)
        #labelDate!.addClass("labelDate")
        
        methodret winTitle!
    methodend
    
    REM /**
    REM  * Creates the toolbar window "winToolBar" with various buttons.
    REM  * @return The toolbar window, as a BBjChildWindow.
    REM  */
    method public BBjChildWindow createWinToolBar()
        winToolBar! = #winMain!.addChildWindow("ToolBar", $00108800$, #sysgui!.getAvailableContext())
        winToolBar!.addClass("winToolBar")
        
        btnAddTask! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='plus'></dwc-icon>")
        btnAddTask!.addClass("toolbar_icon")
        btnAddTask!.setToolTipText("Add Task")
        btnAddTask!.setAttribute("expanse", "xs")
        btnAddTask!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onAddTask")
                 
        btnShowCompletedTasks! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='checks'></dwc-icon>")
        btnShowCompletedTasks!.addClass("toolbar_icon icon-completed")
        btnShowCompletedTasks!.setToolTipText("Completed Tasks")
        btnShowCompletedTasks!.setAttribute("expanse", "xs")
        btnShowCompletedTasks!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onShowCompletedTasks")
                
        btnSettings! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='settings'></dwc-icon>")
        btnSettings!.addClass("toolbar_icon")
        btnSettings!.setToolTipText("Settings")
        btnSettings!.setAttribute("expanse", "xs")
        btnSettings!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onShowSettings")

        btnExport! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='file-download'></dwc-icon>")
        btnExport!.addClass("toolbar_icon")
        btnExport!.setToolTipText("Export tasks")
        btnExport!.setAttribute("expanse", "xs")
        btnExport!.setCallback(BBjControl.ON_BUTTON_PUSH,#this!,"onExport")

        btnImport! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='file-upload'></dwc-icon>")
        btnImport!.addClass("toolbar_icon")
        btnImport!.setToolTipText("Import tasks")
        btnImport!.setAttribute("expanse", "xs")
        btnImport!.setCallback(BBjControl.ON_BUTTON_PUSH,#this!,"onImport")

        btnReload! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='reload'></dwc-icon>")
        btnReload!.addClass("toolbar_icon icon_reload")
        btnReload!.setToolTipText("Reload")
        btnReload!.setAttribute("expanse", "xs")
        btnReload!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onReload")
                
        methodret winToolBar!
    methodend

    REM /**
    REM  * Add a child window to the main window for each task
    REM  * This will eventually need to be a full-blown task manager, probably
    REM  */
    method public void displayTasks()
        declare auto Task task!

        REM Original code that uses the #tasks object which isn't sorted
        REM it! = #tasks!.values().iterator()

        REM New code that gets a sorted TreeMap of the tasks
        #labelDate!.setText("<html>" + date(0:"%Dl, %Ml %D") + $0A$ + "<span style='font-size:50%;'>Tasks Sorted by Priority")
        orderedTasks! = #getSortedTasks("priority")
        it! = orderedTasks!.values().iterator()

        REM TASK LIST VIEW: task loop
        while it!.hasNext()
            task! = it!.next()
            view! = #addTaskListView(task!)

            cardView! = #addTaskCardView(task!)
            if (task!.getComplete()) then
REM                 view!.setVisible(0)
                view!.setVisible(1)
            endif
        wend
    methodend

    REM /**
    REM  * Returns a sorted TreeMap that's similar to the #tasks! TreeMap, except
    REM  * that its key is the priority+dueDate+Uuid (when sorted by priority),
    REM  * or dueDate+priority+Uuid (when sorted by date).  We're concatenating
    REM  * the three fields and letting the TreeMap object sort the tasks for us
    REM  * based on the constructed key.  This new TreeMap still contains the task
    REM  * objects in the value, so it can be used to fill the task list view in
    REM  * a sorted manner.
    REM  *
    REM  * @param BBjString sortType!       The desired sorting type for the returned TreeMap.  Values can be "priority" or "date"
    REM  * @return TreeMap                  A TreeMap where the values are the tasks objects and the key is based on the sorting type
    REM  */
    method public TreeMap getSortedTasks(BBjString sortType!)
        sortedTasks! = new TreeMap()

        it! = #tasks!.keySet().iterator()
        while it!.hasNext()
            uuid! = it!.next()
            task! = #tasks!.get(uuid!)

            REM If the task's priority is 0, meaning that it's unset, then we'll use priority 9 so that it appears at the end of the sorted list
            priority! = task!.getPriority()

            dueDate! = task!.getDueDate()
REM             created! = task!.getCreated()

            if (dueDate! > -1) then
                taskDate! = date(dueDate!:"%Yl-%Mz-%Dz")
            else
                REM If the due date isn't set, then we'll push it into the distant future for correct sorting
                taskDate! = "none"
            endif

            REM This determines the sort order, which is based on the provide parameter
            if (sortType!.toLowerCase().trim().contains("date")) then
                REM Sort by the task's due date
                REM The TreeMap's key will be comprised of the date, then the priority, then the UUID
                key! = taskDate! + str(priority!) + uuid!
            else
                REM Sort by the task's priority
                REM The TreeMap's key will be comprised of the priority, then the date, then the UUID
                key! = str(priority!) + taskDate! + uuid!
            endif

            sortedTasks!.put(key!, task!)
        wend
        methodret sortedTasks!
    methodend

    REM /**
    REM  * Adds a TaskCardView for the given Task, and returns the TaskCardView
    REM  */
    method public TaskCardView addTaskCardView(Task task!)
        if (task!.getComplete()) then
            view! = new TaskCardView(#winTaskCardComplete!, task!)
        else
            view! = new TaskCardView(#winTaskCard!, task!)
        endif
        #winTaskCardComplete!.setVisible(0)
        #taskViews!.put(task!.getUuid(), view!)
        view!.getwin().setCallback(BBjControl.ON_CLICK, #this!, "onTaskClick")
        methodret view!
    methodend

    REM /**
    REM  * Add a Task List Window
    REM  */
    method public BBjChildWindow addTaskList(BBjString name!)
        taskList! = #winTasks!.addChildWindow(name!, $00108800$, #sysgui!.getAvailableContext())
        REM Probably remove winTasks, just use taskList
        taskList!.addClass("taskList fadeIn")
        #vectTaskLists!.addItem(taskList!)
        methodret taskList!
    methodend

    REM /**
    REM  * Adds a TaskListView for the given Task, and returns the TaskListView
    REM  */
    method public TaskListView addTaskListView(Task t!)
        index = 0
        taskList! = #vectTaskLists!.getItem(index)
        view! = new TaskListView(taskList!, t!)

        #taskViews!.put(t!.getUuid(), view!)
        view!.getwin().setCallback(BBjControl.ON_CLICK, #this!, "onTaskClick")
        methodret view!
    methodend

    REM /**
    REM  * Open an edit window to edit or create a new task
    REM  *
    REM  * @param e!    A BBjClickEvent
    REM  */
    method public void onTaskClick(BBjClickEvent e!)
        REM Only open window if it doesn't exist, this should be a field variable
        REM We're not using the click event as a click; it could be more efficient to pass a more useful object
        declare auto Task t!
        if (#taskProperties! = null()) then
            #taskProperties! = new TaskProperties()
        endif
        t! = #tasks!.get(e!.getControl().getAttribute("id"))
        #taskProperties!.loadTask(t!)

        REM TASK CARD VIEW: onTaskClick method
        win! = e!.getControl()
        lock! = "<html><dwc-icon pool='tabler' name='lock' style='width: 30px; height: 30px'></dwc-icon>"
        lockOpen! = "<html><dwc-icon pool='tabler' name='lock-open' style='width: 30px; height: 30px'></dwc-icon>"
        btnLock! = e!.getControl().getUserData()

        if (btnLock! = null()) OR (btnLock!.getText() = lockOpen!) then
            if (#taskProperties! = null()) then
                #taskProperties! = new TaskProperties()
            endif
            t! = #tasks!.get(e!.getControl().getAttribute("id"))
            #taskProperties!.loadTask(t!)
        else
            unlockResult! = msgbox("Would you like to edit task now?", BBjSysGui.MSGBOX_BUTTONS_YES_NO + BBjSysGui.MSGBOX_ICON_INFORMATION, "Unlock Task to Edit")
            if (unlockResult! = 6) then
                if (#taskProperties! = null()) then
                    #taskProperties! = new TaskProperties()
                endif

                btnLock!.setText(lockOpen!)
                btnLock!.removeClass("card-btn-lock")
                btnLock!.addClass("card-btn-lock-open")
                win!.removeClass("card-task-complete")
                win!.addClass("card-task")

                t! = #tasks!.get(e!.getControl().getAttribute("id"))
                #taskProperties!.loadTask(t!)

                dataVector! = BBjAPI().makeVector()
                dataVector!.addItem(win!)
                dataVector!.addItem(btnLock!)
                if (t!.getComplete()) then #taskProperties!.passData(dataVector!)
            endif
        endif

    methodend

    REM /**
    REM  * Creates sample tasks to use for a demo
    REM  *
    REM  * @param numTasks! The number of sample tasks to create
    REM  */
    method public void createSampleTasks(BBjNumber numTasks!)
        declare auto BBjString  taskName!
        declare auto Task       task!

        for i = 0 to numTasks! - 1
            taskName! = "Task " + str(i)
            task! = new Task()
            task!.setTitle(taskName!)
            if (mod(i,2) = 0) then
                REM Set due date for even-numbered tasks
                task!.setDueDate(jul(date(0)))
            endif
            #addTask(task!)
        next i
    methodend

    REM /**
    REM  * Adds a Task to the tasklist (the app's collection of Task objects)
    REM  *
    REM  * @param task!     The Task object
    REM  */
    method public void addTask(Task task!)
        uuid! = task!.getUuid()
        #tasks!.put(uuid!, task!)
    methodend

    REM /**
    REM  * Returns the Task with the given UUID from the TreeMap of tasks.
    REM  */
    method public Task getTask(BBjString uuid!)
        methodret cast(Task, #tasks!.get(uuid!))
    methodend

    REM /**
    REM  * Toggles the layout type for the tasks, alternating betweeen a list (default) and card layout
    REM  */
    method public void OnSwitchChangeLayout(BBjCheckChangeEvent event!)
    REM toggles visibility for both view windows
        #winTasks!.setVisible(!#winTasks!.isVisible())
        #winTaskCardView!.setVisible(!#winTaskCardView!.isVisible())
        methodret
    methodend

    REM /**
    REM  * Activated by custom event TASK_UPDATE
    REM  * This method handles any UI or data updates that may be necessary when a Task is modified.
    REM  *
    REM  * @param event!    A BBjCustomEvent that has a Task Object as a payload.
    REM  */
    method public void onTaskUpdate(BBjCustomEvent event!)
        declare auto TaskListView view!
        declare auto Task t!
        task! = event!.getObject()
        uuid! = task!.getUuid()
        
        Utils.consoleLog("IN ON task update")
        REM If the UUID is not present in #tasks!, this is a new Task to be added.
        if (#tasks!.containsKey(uuid!) = 0) then
            #addTask(task!)
            #addTaskListView(task!)
        endif

        view! = #taskViews!.get(uuid!)
        if (view! <> null()) then
            view!.refresh()
            Utils.consoleLog("refreshed view")
        else
            Utils.consoleLog("did not refresh view")
        endif

        if (task!.getDeleted()) then
            #removeTask(task!)
        endif

        REM Automatically export every time a task is updated
        #onExport(null())

        REM TASK CARD VIEW: onTaskUpdate method
        declare auto TaskCardView view!
        declare auto Task t!
        task! = event!.getObject()
        uuid! = task!.getUuid()
        REM check if dirty
        REM check if task is in list
        if (#tasks!.containsKey(uuid!) = 0) then
            #addTask(task!)
            #addTaskCardView(task!)
        else
            view! = #taskViews!.get(uuid!)
            viewPriority! = #taskPriorityViews!.get(uuid!)
            viewDueDate! = #taskDueDateViews!.get(uuid!)
            if (view! <> null()) then
                view!.refresh()
            endif
            if (viewPriority! <> null()) then
                viewPriority!.refresh()
            endif
            if (viewDueDate! <> null()) then
                viewDueDate!.refresh()
            endif
        endif
        REM Automatically export every time you save
        #onExport(null())
    methodend

    REM /**
    REM  * Removes a Task from the tasklist by specifying the tasks's ID
    REM  *
    REM  * @param id        The task's unique ID
    REM  */
    method public void removeTask(BBjString uuid!)
        #tasks!.remove(uuid!)
        #taskViews!.remove(uuid!)
    methodend

    REM /**
    REM  * Removes a Task from the tasklist by specifying the tasks object
    REM  *
    REM  * @param task!     The Task object
    REM  */
    method public void removeTask(Task task!)
        #tasks!.remove(task!.getUuid())
        #taskViews!.remove(task!.getUuid())
    methodend

    REM /**
    REM  * Displays the app's settings window
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onShowSettings(BBjButtonPushEvent e!)
        if (#settings! = null()) then
            #settings! = new Settings()
        endif
        #settings!.onShowSettings(#hashPrefs!)
    methodend

    REM /**
    REM  * Reloads the application at the push of a button, which is typically only useful in development mode
    REM  * <p>
    REM  * The code creates a BBjBuiUrlCloseAction object to load the app's URL.  That way, the app can
    REM  * do a RELEASE which causes the same app to be loaded and executed again.
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onReload(BBjButtonPushEvent e!)
        action! = #webManager!.urlAction(#webManager!.getUrl())
        #webManager!.setEndAction(action!)
        release
    methodend

    REM /**
    REM  * Adds a new Task object by
    REM  *  - creating a new Task object
    REM  *  - displaying the Task's property sheet to the user for customization
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onAddTask(BBjButtonPushEvent e!)
        REM create a new task
        task! = new Task()
        REM open the edit window on that task
        if (#taskProperties! = null()) then
            #taskProperties! = new TaskProperties()
        endif
        #taskProperties!.loadTask(task!)
    methodend


    REM TASK CARD VIEW: different viewing methods
    REM /**
    REM  * - Toggles visibility of #winTaskCardComplete! which contains all complete task child windows
    REM  * - When toggle is off, displays #winTaskCardIncomplete! which contains all incomplete task child windows
    REM  * - Toggles all related classes
    REM  * - Triggered by #btnCompleteView!
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onShowCompletedTasks(BBjButtonPushEvent e!)
        btnShowCompletedTasks! = e!.getControl()
        btnShowCompletedTasks!.toggleClass("icon-completed-selected")
        if (#taskView! = "incomplete") then
            #taskView! = "complete"
REM             #winTaskCardIncomplete!.setVisible(0)
REM             #btnIncompleteView!.removeClass("view-btn-selected")
REM             #winTaskCardPriority!.setVisible(0)
REM             #btnPriorityView!.removeClass("view-btn-selected")
REM             #winTaskCardDueDate!.setVisible(0)
REM             #btnDueView!.removeClass("view-btn-selected")
REM             #winTaskCardComplete!.setVisible(1)
REM             #labelDay!.setText("Completed Tasks")
REM             #btnIncompleteView!.removeClass("view-btn-selected")
        else
            #taskView! = "incomplete"
REM             #winTaskCardIncomplete!.setVisible(1)
            #winTaskCardComplete!.setVisible(0)
REM             #labelDay!.setText("Today")
REM             #btnIncompleteView!.addClass("view-btn-selected")
        endif
    methodend

REM /**
    REM  * - Toggles visibility of #winTaskCardIncomplete which contains all incomplete task child windows
    REM  * - Toggles all related classes
    REM  * - Triggered by #btnIncompleteView!
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
REM     method public void onIncompleteView(BBjButtonPushEvent e!)
REM         winIncompleteControls! = #winTaskCardIncomplete!.getAllControls()
REM
REM         if (#winTaskCardIncomplete!.isVisible()) then
REM             #winTaskCardIncomplete!.setVisible(0)
REM             #btnIncompleteView!.removeClass("view-btn-selected")
REM         else
REM             #displayType!= 2
REM             #winTaskCardComplete!.setVisible(0)
REM             #winTaskCardPriority!.setVisible(0)
REM             #winTaskCardDueDate!.setVisible(0)
REM
REM             if (winIncompleteControls!.size() = 0) then
REM                 #displayTasks()
REM             else
REM                 #winTaskCardIncomplete!.setVisible(1)
REM             endif
REM
REM             #taskView! = "incomplete"
REM             #labelDay!.setText("Today")
REM             #btnIncompleteView!.addClass("view-btn-selected")
REM             #btnShowCompletedTasks!.removeClass("icon-completed-selected")
REM             #btnPriorityView!.removeClass("view-btn-selected")
REM             #btnDueView!.removeClass("view-btn-selected")
REM         endif
REM     methodend

    REM /**
    REM  * - Toggles visibility of #winTaskCardPriority! which contains all incomplete task child windows organized by Priority
    REM  * - Toggles all related classes
    REM  * - Triggered by #btnPriorityView!
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
REM     method public void onPriorityView(BBjButtonPushEvent e!)
REM         winPriorityControls! = #winTaskCardPriority!.getAllControls()
REM
REM          if (#winTaskCardPriority!.isVisible()) then
REM             #winTaskCardPriority!.setVisible(0)
REM             #btnPriorityView!.removeClass("view-btn-selected")
REM         else
REM             #displayType! = 1
REM             #winTaskCardComplete!.setVisible(0)
REM             #winTaskCardIncomplete!.setVisible(0)
REM             #winTaskCardDueDate!.setVisible(0)
REM
REM             if (winPriorityControls!.size() = 0) then
REM                 #displayTasks()
REM             else
REM                 #winTaskCardPriority!.setVisible(1)
REM             endif
REM
REM             #winTaskCardPriority!.setVisible(1)
REM             #taskView! = "incomplete"
REM             #labelDay!.setText("Today")
REM             #btnIncompleteView!.removeClass("view-btn-selected")
REM             #btnShowCompletedTasks!.removeClass("icon-completed-selected")
REM             #btnDueView!.removeClass("view-btn-selected")
REM             #btnPriorityView!.addClass("view-btn-selected")
REM         endif
REM     methodend

    REM /**
    REM  * - Toggles visibility of #winTaskCardDueDate! which contains all incomplete task child windows organized by Due Date
    REM  * - Toggles all related classes
    REM  * - Triggered by #btnDueView!
    REM  *
    REM  * @param e!        The BBjButtonPushEvent that causes this method to be executed
    REM  */
REM     method public void onDueView(BBjButtonPushEvent e!)
REM         winDueDateControls! = #winTaskCardDueDate!.getAllControls()
REM
REM         if (#winTaskCardDueDate!.isVisible()) then
REM             #winTaskCardDueDate!.setVisible(0)
REM             #btnDueView!.removeClass("view-btn-selected")
REM         else
REM             #displayType! = 0
REM             #winTaskCardComplete!.setVisible(0)
REM             #winTaskCardIncomplete!.setVisible(0)
REM             #winTaskCardPriority!.setVisible(0)
REM
REM             if (winDueDateControls!.size() = 0) then
REM                 #displayTasks()
REM             else
REM                 #winTaskCardDueDate!.setVisible(1)
REM             endif
REM
REM             #winTaskCardDueDate!.setVisible(1)
REM             #taskView! = "incomplete"
REM             #labelDay!.setText("Today")
REM             #btnIncompleteView!.removeClass("view-btn-selected")
REM             #btnShowCompletedTasks!.removeClass("icon-completed-selected")
REM             #btnPriorityView!.removeClass("view-btn-selected")
REM             #btnDueView!.addClass("view-btn-selected")
REM         endif
REM     methodend


    REM /**
    REM  * Callback that's executed when the user selects a custom font family.
    REM  * This gets the list button's selected index, then resolves that to
    REM  * a custom font family that's stored in the #vectFontFamilies!
    REM  * vector.  It then sets the CSS custom property for the DWC's
    REM  * sans-serif font family to the chosen font.
    REM  *
    REM  * BBjListChangeEvent e!    The BBjListButton's ON_LIST_CHANGE event
    REM  */
    method public void onListChangeFontFamilies(BBjListChangeEvent e!)
        declare auto BBjString fontFamily!

        REM Get the selected item from the list
        fontFamilyHtml! = e!.getSelectedItem()

        REM Since the item has HTML markup to style the family namne, remove all the HTML tags
        fontFamily! = fontFamilyHtml!.replaceAll("<[^>]*>", "")

        REM Alternatively, since the backing vector of font families is a global field, we could also
        REM get the selected font family by retrieving the item from the vector.  In this scenario,
        REM we can use the event's getSelectedIndex() method to specify the item's index in the vector.
        REM fontFamily! = str(#vectFontFamilies!.getItem(e!.getSelectedIndex()))

        REM Now set the font for the tasks by setting the CSS custom property that we defined for that purpose
        #setCssProperty("--app-font-family-task", fontFamily!)

        REM Save out the user's preferred task font family in a cookie
        #prefsTaskFontFamily! = fontFamily!
        #hashPrefs!.put("prefsTaskFontFamily", #prefsTaskFontFamily!)
        #setCookies(#appName!, #hashPrefs!, err=*NEXT)
    methodend

    REM /**
    REM  * Utility method that sets a CSS custom property given the property and value.
    REM  * It ensures that the CSS property is properly formatted, then builds a CSS
    REM  * string from the iformation and adds it to the DOM, thus overriding any
    REM  * previous setting
    REM  */
    method public void setCssProperty(BBjString property!, BBjString value!)
        REM Sanitize the property by ensuring that it starts with '--' and changing all spaces to dashes
        if !(property!.startsWith("--")) then property! = "--" + property!
        property! = property!.replaceAll(" ", "-").trim()
        value! = value!.trim()
        if (value!.contains(" ")) then value! = "'" + value! + "'"

        REM Build the CSS string for the root element and append it to the DOM's <body> element
        css! = ":root { " + property! + ": " + value! + "; }"
        #webManager!.injectStyle(css!, 0, "app_custom_css_property")
    methodend

    REM /**
    REM  * Returns the collection of Task objects in a JsonArray.  This is used to
    REM  * serialize the tasks so that they can be exported, shared with another app,
    REM  * or saved to disk.
    REM  *
    REM  * @return JsonArray     The tasks collection as a JsonArray
    REM  */
    method protected JsonArray getTasksAsJsonArray()
        declare JsonArray array!
        declare auto BBjString uuid!
        declare auto Task task!

        array! = new JsonArray()
        it! = #tasks!.keySet().iterator()
        while it!.hasNext()
            uuid! = it!.next()
            task! = #tasks!.get(uuid!)
            array!.add(task!.getAsJsonObject())
        wend
        methodret array!
    methodend

    method public void onExport(BBjButtonPushEvent e!)
        REM todo: check if e! is null
        REM save to default location if null
        REM open save dialog if it's the export button

        REM todo: notify successful export
        json! = #getTasksAsJsonArray()
        gson! = new GsonBuilder().setPrettyPrinting().create()
        chan = unt
        f$ = #appPath! + "tasks.json"
        open(chan, isz=-1, mode="O_TRUNC,O_CREATE") f$
            write record(chan) gson!.toJson(json!).toString()
        close(chan)
        REM #consoleLog("Exported " + str(json!.size()) +  " tasks.")
    methodend

    method public void onImport(BBjButtonPushEvent e!)
        chan = unt
        f$ = #appPath! + "tasks.json"
        open(chan, isz=-1) f$
            read record(chan, siz=-1000000) json$
        close(chan)
        parser! = new JsonParser()
REM         parser!.setLenient(BBjAPI().TRUE)
        json! = parser!.parseString(json$)

        gson! = new GsonBuilder().setPrettyPrinting().create()
        REM #consoleLog(json!.toString())
        array! = gson!.fromJson(json!, JsonArray.class)
        it! = array!.iterator()
        REM todo: clear treemap after checking if there are any tasks to import
        REM todo: Error handling: what if the file doesn't exist? What if tasks aren't valid?
        REM we could return something; number of imported tasks or something
        while(it!.hasNext())
            jsonTask! = it!.next()
            t! = new Task(jsonTask!)
            #addTask(t!)
        wend
    methodend


    REM /**
    REM  * Method to set multiple string-based user preferences via a HashMap to reduce client-server round trips
    REM  * <p>
    REM  * The get/setCookies() methods bypasses the effort of creating string templates and BBjTemplatedStrings as well as encoding
    REM  * information for safety and portability.  You only have to provide a unique key value that's used to
    REM  * store the information (usually the app's name, but it can be virtually any string) and a HashMap filled
    REM  * with the information to store.  The method iterates through the HashMap's keys and builds a string
    REM  * that consists of the HashMap's key/value pairs joined by the <code>"-,-"</code> characters in an
    REM  * attempt to provide a reasonable separator that won't interfere with the stored data.
    REM  * <p>
    REM  * Both get/setCookies() methods throw errors, so you may want to add an <code>,err=</code> branch when
    REM  * calling these methods.  The getCookies() method will return a Hashmap filled with key/value pairs if
    REM  * the cookie exists.  If it does not exist, it will return <code>null()</code>.
    REM  * <p>
    REM  * The corresponding <code>getCookies()</code> method is used to retrieve the stored information from the
    REM  * client's computer (GUI) or browser (BUI).  You only need to provide the unique key value when getting
    REM  * the saved cookies, greatly simplifying the reading/writing of user properties
    REM  *
    REM  * @param p_cookieKey$          A BBjString with the unique identifier for the saved cookie, such as the application's name
    REM  * @param p_cookieHashMap!      A HashMap filled with key/value pairs to be stored where the key is the field name and the value is the string value for that field
    REM  *
    REM  * @see <a href='https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html' target='_blank'>HashMap</a> for more information on the Java HashMap object
    REM  */
    method public static void setCookies(BBjString p_cookieKey$, HashMap p_cookieHashMap!)
        it! = p_cookieHashMap!.keySet().iterator()
        while it!.hasNext()
            key$ = it!.next()
            value$ = str(p_cookieHashMap!.get(key$))
            fullString$ = fullString$ + key$ + "-,-" + value$ + $0A$
        wend
        fullString$ = fullString$(1, len(fullString$)-1)

        REM Encode the string contents and store it in the user properties based on the provided application key
        encodedCookies$ = URLEncoder.encode(fullString$)
        tc! = BBjAPI().getThinClient(err=ERR_GETTING_THINCLIENT)
        tc!.setUserProperty(p_cookieKey$, encodedCookies$, err=ERR_WRITING_COOKIE)
        methodret

        ERR_GETTING_THINCLIENT:
        throw "Error getting the BBjThinClient when trying to set cookies.  The error message was: " + errmes(-1), 725

        ERR_WRITING_COOKIE:
        throw "Error saving cookie.  The error message was: " + errmes(-1), 720
    methodend


    REM /**
    REM  * Method to get multiple string-based user preferences in a HashMap to reduce client-server round trips
    REM  * <p>
    REM  * The get/setCookies() methods offer a simple way to persist application setting via a HashMap.  You
    REM  * save information by calling the setCookies() method providing a unique key value that's used to
    REM  * store the information (usually the app's name, but it can be virtually any string) and a HashMap filled
    REM  * with the information to store.  You can then call the getCookies() method to retrieve the saved
    REM  * information in a HashMap.  The methods bypass the effort of creating string templates and BBjTemplatedStrings
    REM  * as well as encoding information for safety and portability.
    REM  * <p>
    REM  * Both get/setCookies() methods throw errors, so you may want to add an <code>,err=</code> branch when
    REM  * calling these methods.  The getCookies() method will return a Hashmap filled with key/value pairs if
    REM  * the cookie exists.  If it does not exist, it will return <code>null()</code>.
    REM  *
    REM  * @param p_cookieKey$          A BBjString with the unique identifier for the saved cookie, such as the application's name
    REM  *
    REM  * @return                      A HashMap filled with key/value pairs, basically a clone of the HahMap provided to the setCookies() method.  If the cookie doesn't exist on the client's machine or browser, the method retuns null().
    REM  */
    method public static HashMap getCookies(BBjString p_cookieKey$)
        declare HashMap             hashCookies!

        tc! = BBjAPI().getThinClient(err=ERR_GETTING_THINCLIENT)
        prop$ = tc!.getUserProperty(p_cookieKey$, ERR=ERR_READING_COOKIE)
        cookieValue! = URLDecoder.decode(prop$)
        if (cookieValue! <> null()) then
            hashCookies! = new HashMap()
            fieldList! = java.util.Arrays.asList(cookieValue!.split($0A$))
            for fieldNum = 0 to fieldList!.size()-1
                keyVal! = fieldList!.get(fieldNum)
                keyValVector! = java.util.Arrays.asList(keyVal!.split("-,-"))
                hashCookies!.put(keyValVector!.get(0,err=*NEXT), keyValVector!.get(1,err=*NEXT))
            next
        endif
        methodret hashCookies!

        ERR_GETTING_THINCLIENT:
        throw "Error getting the BBjThinClient when trying to get cookies.  The error message was: " + errmes(-1), 725

        ERR_READING_COOKIE:
        if (err=11) then
            methodret null()
        else
            throw "Error: " + str(err) + ", With error message: " + errmes(-1), 720
        endif
    methodend

classend


REM BBj USE Statements
use ::Task.bbj::Task
use ::TaskProperties.bbj::TaskProperties
use ::TaskListView.bbj::TaskListView
use ::TaskView.bbj::TaskView
use ::Settings.bbj::Settings
use ::TaskCardView.bbj::TaskCardView
use ::Utils.bbj::Utils

REM Java USE Statements
use java.time.LocalDate
use java.util.TreeMap
use java.util.HashMap
use java.net.URLEncoder
use java.net.URLDecoder

REM Google's Gson for JSON, which is included with BBj
use com.google.gson.Gson;           REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/Gson.html
use com.google.gson.GsonBuilder;    REM https://javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/GsonBuilder.html
use com.google.gson.JsonObject;     REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/JsonObject.html
use com.google.gson.JsonArray;      REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/JsonArray.html
use com.google.gson.JsonParser;     REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/JsonParser.html