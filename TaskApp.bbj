REM /**
REM  * TaskApp.bbj
REM  * @author gosteen, ndecker, bhighhill
REM  */
REM package TaskApp


declare auto TaskApp app!
app! = new TaskApp()
app!.run()
end


REM /**
REM  * A DWC-specific task manager BBj program.
REM  *
REM  * The TaskApp program was designed to a be part of a tutorial series that covers
REM  * how to write a graphical web-based application in BBj. It's designed to run
REM  * in the BASIS Dynamic Web Client (DWC), and takes advantage of several DWC
REM  * features including light/dark theme support, responsive design, and making
REM  * use of 3rd-party web components.
REM  */
class public TaskApp

    REM Protected Fields
    REM ========================================
    field protected BBjSysGui           sysgui!
    field protected BBjWebManager       webManager!
    field protected BBjTopLevelWindow   winMain!
    field protected TaskProperties      taskProperties!
    field protected Settings            settings!
    field protected TaskCardView        taskCardView! = new TaskCardView()
    field protected BBjChildWindow      winToolBar!
    field protected BBjChildWindow      winTitle!
    field protected BBjChildWindow      winViews!
    field protected BBjChildWindow      winTaskCard!
    field protected BBjChildWindow      winTaskCardIncomplete!
    field protected BBjChildWindow      winTaskCardComplete!
    field protected BBjChildWindow      winTaskCardPriority!
    field protected BBjChildWindow      winTaskCardDueDate!
    field protected BBjChildWindow      winTasks!
    field public    BBjChildWindow      winTasksCardView!
    field protected BBjVector           vectTaskLists! = BBjAPI().makeVector()
    field protected BBjWebComponent     segmentChangeView!

    REM NavBar and ToolBar controls
    field protected BBjButton           btnAddTaskFAB!

    REM Misc Data
    field protected BBjString           appName! = "TaskApp"
    field protected BBjString           version! = "0.1"
    field protected BBjString           appPath! = dsk("") + dir("")
    field public    BBjString           taskView! = "incomplete"
    field public    BBjButton           btnIncompleteView!
    field public    BBjButton           btnCompleteView!
    field public    BBjButton           btnPriorityView!
    field public    BBjButton           btnDueView!
    field public    BBjNumber           displayType! = 2

    REM Some sort of list of tasks.
    REM ========================================
    REM It could be a BBjVector or BBjArray of tasks.
    REM It could also be a Java Collection class like:
    REM     Set     https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Set.html
    REM     List    https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html
    REM     Map     https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html
    REM /**
    REM  * A collection of Task objects in a Java TreeMap
    REM  * Key:   UUID of the Task
    REM  * Value: Task object
    REM  * @see <a href='https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/TreeMap.html' target='_blank'>TreeMap</a> documentation
    REM  */
    field protected TreeMap tasks!
    field protected TreeMap taskListViews!
    field protected TreeMap taskCardViews!
    field protected TreeMap taskPriorityViews!
    field protected TreeMap taskDueDateViews!

    REM Constants
    REM ========================================
    REM /** A constant value that's used to set the TaskApp's theme to the DWC's light theme */
    method public static BBjString THEME_LIGHT()
        methodret "light"
    methodend
    REM /** A constant value that's used to set the TaskApp's theme to the DWC's dark theme */
    method public static BBjString THEME_DARK()
        methodret "dark"
    methodend
    REM /** A constant value that's used to set the TaskApp's theme to the DWC's system theme,
    REM  * meaning that it follows the operating system's configuration.  For example, when the
    REM  * user's device switches to its dark theme, then the app will also switch its theme
    REM  * to the DWC's dark theme. */
    method public static BBjString THEME_SYSTEM()
        methodret "system"
    methodend

    REM Define the user preferences which will be stored in a HashMap and saved out as a cookie
    REM ========================================
    REM /** The hashmap that stores all the user's preferences */
    field private HashMap hashPrefs!
    REM /** The user's preferred DWC theme to use for the UI, i.e. light, dark, dark-pure, or system */
    field protected BBjString prefsTheme! = #THEME_SYSTEM()
    REM /** The user's preferred font family (CSS: font-family)for the tasks */
    field protected BBjString prefsTaskFontFamily! = "Rambla"
    REM /** The user's preferred font weight (CSS: font-weight)for the tasks */
    field protected BBjString prefsTaskFontWeight! = "var(--dwc-font-weight-bold)"
    REM /** The user's preferred font size for the tasks.
    field protected BBjString prefsTaskFontSize! = "var(--dwc-font-size-m)"
    REM /** The user's preferred font letter spacing (CSS: letter-spacing) for the tasks.  This will usually be 'normal', but can be a length as in '0.5px'. */
    field protected BBjString prefsTaskFontSpacing! = "normal"
    REM /** The user's preferred task view layout: card or list. */
    field protected BBjString prefsTaskView! = "list"
    REM /** The user's preferred global hue color to tint the app. */
    field protected BBjString prefsTaskHue! = "15"
    REM /** The user's preferred font weight for the tasks */
    field protected BBjNumber prefsDefaultTaskPriority! = 3
    REM /** The TaskApp's version, used for display purposes only */
    field protected BBjString prefsVersion! = #version!


    REM Constructors
    REM ========================================
    method public TaskApp()
        REM Instatiate the WebManager and use it to inject the app's CSS
        #webManager! = BBjAPI().getWebManager()
        #injectCSSFile("TaskApp.css")
        #injectCSSFile("taskView.css")
        #injectCSSFile("taskListView.css")
        #injectCSSFile("taskCardView.css")
        #injectCSSFile("Settings.css")

        REM ' set legacy BBj className values when running in DWC.
        REM if info(3,6)="6" then
        REM     bbjapi().getWebManager().setAttribute("dwc.class","true")
        REM endif

        REM Set the app's icon in the browser's tab
        url! = "https://public.basis.cloud/images/DWCTaskApp.svg"
        attrib! = "rel=icon,type=image/svg,id=dwc_taskapp_icon"
        #webManager!.injectLinkUrl(url!, 1, attrib!, err=*NEXT)

        rem Set the title of the app
        #webManager!.setTitle("TaskApp")

        rem Set the homescreen icon for smartphones and tablets
        url! = "https://public.basis.cloud/images/DWCTaskApp.png"
        #webManager!.injectLinkUrl(url!, 1, "rel=SHORTCUT ICON,type=image/png")
        #webManager!.injectLinkUrl(url!, 1, "rel=apple-touch-icon,type=image/png")
        #webManager!.injectLinkUrl(url!, 1, "rel=icon,type=image/png")

        REM Inject links for Ionic Web Components
        url! = "https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.esm.js"
        #webManager!.injectScriptUrl(url!,1,"type=module")

        url! = "https://cdn.jsdelivr.net/npm/@ionic/core/dist/ionic/ionic.js"
        #webManager!.injectScriptUrl(url!,1,"type=module")

        REM Create the collection for the tasks
        #tasks! = new TreeMap()
        #taskListViews! = new TreeMap()
        #taskCardViews! = new TreeMap()
        #taskPriorityViews! = new TreeMap()
        #taskDueDateViews! = new TreeMap()

        REM Create the HashMap to store the user preferences and load it up with the default values
        #hashPrefs! = new HashMap()
        #hashPrefs!.put("prefsTheme", #prefsTheme!)
        #hashPrefs!.put("prefsTaskFontFamily", #prefsTaskFontFamily!)
        #hashPrefs!.put("prefsTaskFontWeight", #prefsTaskFontWeight!)
        #hashPrefs!.put("prefsTaskFontSize", #prefsTaskFontSize!)
        #hashPrefs!.put("prefsTaskFontSpacing", #prefsTaskFontSpacing!)
        #hashPrefs!.put("prefsDefaultTaskPriority", #prefsDefaultTaskPriority!)
        #hashPrefs!.put("prefsTaskView", #prefsTaskView!)
        #hashPrefs!.put("prefsTaskHue", #prefsTaskHue!)
        #hashPrefs!.put("prefsVersion", #prefsVersion!)

        REM Read the user's preferences from a cookie, then apply all saved values to the HashMap of user preferences
        REM This means that the HashMap that was initially filled with default values will now contain the user's saved preferences
        hashPrefsFromCookie! = Utils.getCookies(#appName!,err=*NEXT)
        if (hashPrefsFromCookie! <> null()) then
            it! = hashPrefsFromCookie!.keySet().iterator()
            while (it!.hasNext())
                key! = it!.next()
                if (#hashPrefs!.containsKey(key!)) then
                    value! = hashPrefsFromCookie!.get(key!)
                    #hashPrefs!.put(key!, str(value!))
                endif
            wend
        endif

        REM Register for a custom event that the TaskProperties fires after the user is done editing or adding a task
        BBjAPI().setCustomEventCallback("TASK_UPDATE",#this!,"onTaskUpdate")

        REM Register for a custom event that the user has  modified their preferences via the Settings dialog
        BBjAPI().setCustomEventCallback("SETTINGS_UPDATE",#this!,"onSettingsUpdate")
    methodend


    REM Methods
    REM ========================================
    REM /**
    REM  * Runs the TaskApp application
    REM  */
    method public void run()
        #onImport(null())

        REM Create the UI and display the tasks
        #sysgui! = BBjAPI().openSysGui("X0")
        #createMainWindow()
        process_events
    methodend

    REM /**
    REM  * Create the main window for the application
    REM  */
    method public void createMainWindow()
        #winMain! = #sysgui!.addWindow("TaskApp", $011C1091$)
        #winMain!.addClass("winMain fadeIn")
        #winMain!.setIcon(#appPath!+"images/DWCTaskApp.png")

        #winToolBar! = #createWinToolBar()
        #winTitle! = #createWinTitle()

        REM TASK LIST VIEW: main window
        #winTasks! = #winMain!.addChildWindow("Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTasks!.addClass("winTasks")

        REM TASK CARD VIEW: main window
        #winTasksCardView! = #winMain!.addChildWindow("Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTasksCardView!.addClass("winTaskCardView")
        #winTasksCardView!.setVisible(0)

        #winTaskCard! = #winTasksCardView!.addChildWindow("All Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTaskCard!.addClass("winCardTasks fadeIn")
        #winTaskCardComplete! = #winTasksCardView!.addChildWindow("Completed Tasks", $00108800$, #sysgui!.getAvailableContext())
        #winTaskCardComplete!.addClass("winCardTasks fadeIn")
        #winTaskCardComplete!.setVisible(0)

        #addTaskList("default")

        REM Create the FAB (floating action button) and the toolbar buttons
        #btnAddTaskFAB! = #winMain!.addButton("<html><dwc-icon pool='tabler' name='plus'></dwc-icon>")
        #btnAddTaskFAB!.addClass("btnAddTaskFAB")
        #btnAddTaskFAB!.setAttribute("theme", "primary")
        #btnAddTaskFAB!.setAttribute("expanse", "xs")
        #btnAddTaskFAB!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onAddTask")

        REM Apply the user's preferences, then display the tasks and set the main window visible
        #applyUserPreferences()
        #displayTasks()
        #winMain!.setVisible(1)
    methodend

    REM /**
    REM  * Creates the winTitle window with the date and day labels.
    REM  * @return BBjChildWindow   The BBjChildWindow that holds the title elements.
    REM  */
    method public BBjChildWindow createWinTitle()
        winTitle! = #winMain!.addChildWindow("Title", $00108800$, #sysgui!.getAvailableContext())
        winTitle!.addClass("winTitle")

        labelDay! = winTitle!.addStaticText("Today", $4000$)
        labelDay!.addClass("labelDay")
        labelDay!.setName("labelDay")
        labelDate! = winTitle!.addStaticText(date(0:"%Dl, %Ml %D"), $4000$)
        labelDate!.addClass("labelDate")
        labelDate!.setName("labelDate")

        #segmentChangeView! = cast(BBjWebComponent, winTitle!.addWebComponent("ion-segment"))
        #segmentChangeView!.setAttribute("value","list")
        #segmentChangeView!.setAttribute("mode","md")

        eventOptions! = #segmentChangeView!.newEventOptions()
        eventOptions!.addItem("value","event.target.value")

        segmentCardView! = winTitle!.addWebComponent("ion-segment-button")
        segmentCardView!.setAttribute("value","card")
        segmentCardView!.setHtml("Card View")

        segmentListView! = winTitle!.addWebComponent("ion-segment-button")
        segmentListView!.setAttribute("value","list")
        segmentListView!.setHtml("List View")

        #segmentChangeView!.setSlot(segmentListView!)
        #segmentChangeView!.setSlot(segmentCardView!)

        #segmentChangeView!.setCallback("ionChange", #this!, "OnChangeLayout", eventOptions!)

        methodret winTitle!
    methodend

    REM /**
    REM  * Creates the toolbar window "winToolBar" with various buttons.
    REM  * @return BBjChildWindow   The toolbar window, as a BBjChildWindow.
    REM  */
    method public BBjChildWindow createWinToolBar()
        winToolBar! = #winMain!.addChildWindow("ToolBar", $00108800$, #sysgui!.getAvailableContext())
        winToolBar!.addClass("winToolBar")

        btnAddTask! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='plus'></dwc-icon>")
        btnAddTask!.addClass("toolbar_icon")
        btnAddTask!.setToolTipText("Add Task")
        btnAddTask!.setAttribute("expanse", "xs")
        btnAddTask!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onAddTask")

        btnShowCompletedTasks! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='checks'></dwc-icon>")
        btnShowCompletedTasks!.addClass("toolbar_icon icon-completed")
        btnShowCompletedTasks!.setToolTipText("Completed Tasks")
        btnShowCompletedTasks!.setAttribute("expanse", "xs")
        btnShowCompletedTasks!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onShowCompletedTasks")

        btnSettings! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='settings'></dwc-icon>")
        btnSettings!.addClass("toolbar_icon")
        btnSettings!.setToolTipText("Settings")
        btnSettings!.setAttribute("expanse", "xs")
        btnSettings!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onShowSettings")

        btnExport! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='file-download'></dwc-icon>")
        btnExport!.addClass("toolbar_icon")
        btnExport!.setToolTipText("Export tasks")
        btnExport!.setAttribute("expanse", "xs")
        btnExport!.setCallback(BBjControl.ON_BUTTON_PUSH,#this!,"onExport")

        btnImport! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='file-upload'></dwc-icon>")
        btnImport!.addClass("toolbar_icon")
        btnImport!.setToolTipText("Import tasks")
        btnImport!.setAttribute("expanse", "xs")
        btnImport!.setCallback(BBjControl.ON_BUTTON_PUSH,#this!,"onImport")

        btnReload! = winToolBar!.addButton("<html><dwc-icon pool='tabler' name='reload'></dwc-icon>")
        btnReload!.addClass("toolbar_icon icon_reload")
        btnReload!.setToolTipText("Reload")
        btnReload!.setAttribute("expanse", "xs")
        btnReload!.setCallback(BBjControl.ON_BUTTON_PUSH, #this!, "onReload")

        methodret winToolBar!
    methodend

    REM /**
    REM  * Add a child window to the main window for each task
    REM  * This will eventually need to be a full-blown task manager, probably
    REM  */
    method public void displayTasks()
        declare auto Task task!

        REM Original code that uses the #tasks object which isn't sorted
        REM it! = #tasks!.values().iterator()

        REM New code that gets a sorted TreeMap of the tasks
        #winTitle!.getControl("labelDate").setText("<html>" + date(0:"%Dl, %Ml %D") + $0A$ + "<span class='labelSortingIndicator'>Tasks Sorted by Priority")
        orderedTasks! = #getSortedTasks("priority")
        it! = orderedTasks!.values().iterator()

        REM TASK LIST VIEW: task loop
        while it!.hasNext()
            task! = it!.next()
            view! = #addTaskListView(task!)

            cardView! = #addTaskCardView(task!)
            if (task!.getComplete()) then
                view!.setVisible(1)
            endif
        wend
    methodend

    REM /**
    REM  * Returns a sorted TreeMap that's similar to the #tasks! TreeMap, except
    REM  * that its key is the priority+dueDate+Uuid (when sorted by priority),
    REM  * or dueDate+priority+Uuid (when sorted by date).  We're concatenating
    REM  * the three fields and letting the TreeMap object sort the tasks for us
    REM  * based on the constructed key.  This new TreeMap still contains the task
    REM  * objects in the value, so it can be used to fill the task list view in
    REM  * a sorted manner.
    REM  *
    REM  * @param BBjString sortType!       The desired sorting type for the returned TreeMap.  Values can be "priority" or "date"
    REM  * @return TreeMap                  A TreeMap where the values are the tasks objects and the key is based on the sorting type
    REM  */
    method public TreeMap getSortedTasks(BBjString sortType!)
        sortedTasks! = new TreeMap()

        it! = #tasks!.keySet().iterator()
        while it!.hasNext()
            uuid! = it!.next()
            task! = #tasks!.get(uuid!)

            REM If the task's priority is 0, meaning that it's unset, then we'll use priority 9 so that it appears at the end of the sorted list
            priority! = task!.getPriority()

            dueDate! = task!.getDueDate()

            if (dueDate! > -1) then
                taskDate! = date(dueDate!:"%Yl-%Mz-%Dz")
            else
                REM If the due date isn't set, then we'll push it into the distant future for correct sorting
                taskDate! = "none"
            endif

            REM This determines the sort order, which is based on the provide parameter
            if (sortType!.toLowerCase().trim().contains("date")) then
                REM Sort by the task's due date
                REM The TreeMap's key will be comprised of the date, then the priority, then the UUID
                key! = taskDate! + str(priority!) + uuid!
            else
                REM Sort by the task's priority
                REM The TreeMap's key will be comprised of the priority, then the date, then the UUID
                key! = str(priority!) + taskDate! + uuid!
            endif

            sortedTasks!.put(key!, task!)
        wend
        methodret sortedTasks!
    methodend

    REM /**
    REM  * Adds a TaskCardView for the given Task, and returns the TaskCardView
    REM  *
    REM  * @param Task task!        Task that will be made into a TaskCardView
    REM  * @return TaskCardView     A TaskCardView containing information from the task
    REM  */
    method public TaskCardView addTaskCardView(Task task!)
        if (task!.getComplete()) then
            view! = new TaskCardView(#winTaskCardComplete!, task!)
        else
            view! = new TaskCardView(#winTaskCard!, task!)
        endif
        #winTaskCardComplete!.setVisible(0)
        #taskCardViews!.put(task!.getUuid(), view!)
        view!.getwin().setCallback(BBjControl.ON_CLICK, #this!, "onTaskClick")
        methodret view!
    methodend

    REM /**
    REM  * Add a Task List Window
    REM  *
    REM  * @param BBjString name!   The name of the task list
    REM  * @return BBjChildWindow   The task list window with the given name
    REM  */
    method public BBjChildWindow addTaskList(BBjString name!)
        taskList! = #winTasks!.addChildWindow(name!, $00108800$, #sysgui!.getAvailableContext())
        taskList!.addClass("taskList fadeIn")
        #vectTaskLists!.addItem(taskList!)
        methodret taskList!
    methodend

    REM /**
    REM  * Adds a TaskListView for the given Task, and returns the TaskListView
    REM  *
    REM  * @param Task t!       Task that will be used to create the TaskListView
    REM  * @return TaskListView The view control for the given task
    REM  */
    method public TaskListView addTaskListView(Task task!)
        index = 0
        taskList! = #vectTaskLists!.getItem(index)
        view! = new TaskListView(taskList!, task!)

        #taskListViews!.put(task!.getUuid(), view!)
        view!.getwin().setCallback(BBjControl.ON_CLICK, #this!, "onTaskClick")
        methodret view!
    methodend

    REM /**
    REM  * Open an edit window to edit or create a new task
    REM  *
    REM  * @param e!    A BBjClickEvent
    REM  */
    method public void onTaskClick(BBjClickEvent e!)
        REM Only open window if it doesn't exist, this should be a field variable
        REM We're not using the click event as a click; it could be more efficient to pass a more useful object
        declare auto Task t!
        if (#taskProperties! = null()) then
            #taskProperties! = new TaskProperties()
        endif
        t! = #tasks!.get(e!.getControl().getAttribute("id"))
        #taskProperties!.loadTask(t!)

        REM TASK CARD VIEW: onTaskClick method
        win! = e!.getControl()
        lock! = "<html><dwc-icon pool='tabler' name='lock' style='width: 30px; height: 30px'></dwc-icon>"
        lockOpen! = "<html><dwc-icon pool='tabler' name='lock-open' style='width: 30px; height: 30px'></dwc-icon>"
        btnLock! = e!.getControl().getUserData()

        if (btnLock! = null()) OR (btnLock!.getText() = lockOpen!) then
            if (#taskProperties! = null()) then
                #taskProperties! = new TaskProperties()
            endif
            t! = #tasks!.get(e!.getControl().getAttribute("id"))
            #taskProperties!.loadTask(t!)
        else
            unlockResult! = msgbox("Would you like to edit task now?", BBjSysGui.MSGBOX_BUTTONS_YES_NO + BBjSysGui.MSGBOX_ICON_INFORMATION, "Unlock Task to Edit")
            if (unlockResult! = 6) then
                if (#taskProperties! = null()) then
                    #taskProperties! = new TaskProperties()
                endif

                btnLock!.setText(lockOpen!)
                btnLock!.removeClass("card-btn-lock")
                btnLock!.addClass("card-btn-lock-open")
                win!.removeClass("card-task-complete")
                win!.addClass("card-task")

                t! = #tasks!.get(e!.getControl().getAttribute("id"))
                #taskProperties!.loadTask(t!)

                dataVector! = BBjAPI().makeVector()
                dataVector!.addItem(win!)
                dataVector!.addItem(btnLock!)
                if (t!.getComplete()) then #taskProperties!.passData(dataVector!)
            endif
        endif

    methodend

    REM /**
    REM  * Creates sample tasks to use for a demo
    REM  *
    REM  * @param BBjNumber numTasks! The number of sample tasks to create
    REM  */
    method public void createSampleTasks(BBjNumber numTasks!)
        declare auto BBjString  taskName!
        declare auto Task       task!

        for i = 0 to numTasks! - 1
            taskName! = "Task " + str(i)
            task! = new Task()
            task!.setTitle(taskName!)
            if (mod(i,2) = 0) then
                REM Set due date for even-numbered tasks
                task!.setDueDate(jul(date(0)))
            endif
            #addTask(task!)
        next i
    methodend

    REM /**
    REM  * Adds a Task to the tasklist (the app's collection of Task objects)
    REM  *
    REM  * @param Task task!    The Task object
    REM  */
    method public void addTask(Task task!)
        uuid! = task!.getUuid()
        #tasks!.put(uuid!, task!)
    methodend

    REM /**
    REM  * Returns the Task with the given UUID from the TreeMap of tasks.
    REM  *
    REM  * @param BBjString uuid!   The UUID of the task to be retrieved.
    REM  * @return Task             The task from the TreeMap of tasks with the given UUID
    REM  */
    method public Task getTask(BBjString uuid!)
        methodret cast(Task, #tasks!.get(uuid!))
    methodend


    REM /**
    REM  * Toggles the layout type for the tasks, alternating betweeen a list (default) and card layout
    REM  *
    REM  * @param BBjWebEvent event!    The BBjWebEvent object that triggered this method
    REM  */
    method public void OnChangeLayout(BBjWebEvent event!)
        REM Get the chosen layout type, which is either "list" or "card", and save it to the preferences
        #prefsTaskView! = event!.getEventMap().get("value").toString()
        #hashPrefs!.put("prefsTaskView", #prefsTaskView!)
        Utils.setCookies(#appName!, #hashPrefs!, err=*NEXT)

        REM Show the list or card window based on the chosen layout
        showListview = #prefsTaskView! = "list"
        #winTasks!.setVisible(showListview,err=*NEXT)
        #winTasksCardView!.setVisible(!showListview,err=*NEXT)
    methodend

    REM /**
    REM  * Activated by custom event TASK_UPDATE
    REM  * This method handles any UI or data updates that may be necessary when a Task is modified.
    REM  *
    REM  * @param BBjCustomEvent event! A BBjCustomEvent that has a Task Object as a payload.
    REM  */
    method public void onTaskUpdate(BBjCustomEvent event!)
        declare auto TaskListView view!
        declare auto Task t!
        task! = event!.getObject()
        uuid! = task!.getUuid()

        rem If the UUID is not present in #tasks!, this is a new Task to be added.
        if (#tasks!.containsKey(uuid!) = 0) then
            #addTask(task!)
            #addTaskListView(task!)
            #addTaskCardView(task!)
        else
            listView! = #taskListViews!.get(uuid!)
            cardView! = #taskCardViews!.get(uuid!)
            viewPriority! = #taskPriorityViews!.get(uuid!)
            viewDueDate! = #taskDueDateViews!.get(uuid!)
            if (listView! <> null()) then listView!.refresh()
            if (cardView! <> null()) then cardView!.refresh()
            if (viewPriority! <> null()) then viewPriority!.refresh()
            if (viewDueDate! <> null()) then viewDueDate!.refresh()
        endif

        if (task!.getDeleted()) then
            #removeTask(task!)
        endif

        REM Automatically export every time a task is updated
        #onExport(null())
    methodend

    REM /**
    REM  * Activated by custom event SETTINGS_UPDATE
    REM  * This method handles any UI or data updates that may be necessary when the user's preferences are modified.
    REM  *
    REM  * @param BBjCustomEvent event! A BBjCustomEvent that has the updated preferences HashMap as a payload.
    REM  */
    method public void onSettingsUpdate(BBjCustomEvent event!)
        #hashPrefs! = cast(HashMap, event!.getObject())
        #applyUserPreferences()
    methodend


    REM /**
    REM  * Sets the field variables from the preferences HashMap and applies them to the user interface.
    REM  *
    REM  * @param BBjCustomEvent event! A BBjCustomEvent that has the updated preferences HashMap as a payload.
    REM  */
    method public void applyUserPreferences()
        REM Get the preferences from the HashMap and apply the values to our field variables
        #prefsTheme! = #hashPrefs!.get("prefsTheme").toString()
        #prefsTaskFontFamily! = #hashPrefs!.get("prefsTaskFontFamily").toString()
        #prefsTaskFontWeight! = #hashPrefs!.get("prefsTaskFontWeight").toString()
        #prefsTaskFontSize! = #hashPrefs!.get("prefsTaskFontSize").toString()
        #prefsTaskFontSpacing! = #hashPrefs!.get("prefsTaskFontSpacing").toString()
        #prefsTaskView! = #hashPrefs!.get("prefsTaskView").toString()
        #prefsTaskHue! = #hashPrefs!.get("prefsTaskHue").toString()
        #prefsDefaultTaskPriority! = num(#hashPrefs!.get("prefsDefaultTaskPriority"))

        REM Now apply the user preferences
        #webManager!.setTheme(#prefsTheme!, err=*NEXT)
        #setCssProperty("--app-color-h", #prefsTaskHue!)
        #setCssProperty("--app-font-family-task", #prefsTaskFontFamily!)
        #setCssProperty("--app-font-weight-task", #prefsTaskFontWeight!)
        #setCssProperty("--app-font-size-task", #prefsTaskFontSize!)
        #setCssProperty("--app-font-spacing-task", #prefsTaskFontSpacing!)

        showListview = #prefsTaskView! = "list"
        #winTasks!.setVisible(showListview,err=*NEXT)
        #winTasksCardView!.setVisible(!showListview,err=*NEXT)
        #segmentChangeView!.setAttribute("value",#prefsTaskView!)

        REM Ensure the preferred font works if it's a Google font
        fontFamilyLink! = "https://fonts.googleapis.com/css2?family=" + #prefsTaskFontFamily! + "&display=swap"
        #webManager!.injectLinkUrl(fontFamilyLink!, 0, "rel=stylesheet")

        REM Save out the user's preferences in a cookie
        Utils.setCookies(#appName!, #hashPrefs!, err=*NEXT)
    methodend


    REM /**
    REM  * Removes a Task from the tasklist by specifying the tasks's ID
    REM  *
    REM  * @param BBjString uuid!        The task's unique ID
    REM  */
    method public void removeTask(BBjString uuid!)
        #tasks!.remove(uuid!)
        #taskListViews!.remove(uuid!)
        #taskCardViews!.remove(uuid!)
    methodend

    REM /**
    REM  * Removes a Task from the task list by specifying the tasks object
    REM  *
    REM  * @param Task task!    The Task object
    REM  */
    method public void removeTask(Task task!)
        #removeTask(task!.getUuid())
    methodend

    REM /**
    REM  * Displays the app's settings window
    REM  *
    REM  * @param BBjButtonPushEvent e! The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onShowSettings(BBjButtonPushEvent e!)
        if (#settings! = null()) then
            #settings! = new Settings()
        endif
        #settings!.onShowSettings(#hashPrefs!)
    methodend

    REM /**
    REM  * Reloads the application at the push of a button, which is typically only useful in development mode
    REM  * <p>
    REM  * The code creates a BBjBuiUrlCloseAction object to load the app's URL.  That way, the app can
    REM  * do a RELEASE which causes the same app to be loaded and executed again.
    REM  *
    REM  * @param BBjButtonPushEvent e! The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onReload(BBjButtonPushEvent e!)
        action! = #webManager!.urlAction(#webManager!.getUrl())
        #webManager!.setEndAction(action!)
        release
    methodend

    REM /**
    REM  * Adds a new Task object by
    REM  *  - creating a new Task object
    REM  *  - displaying the Task's property sheet to the user for customization
    REM  *
    REM  * @param BBjButtonPushEvent e! The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onAddTask(BBjButtonPushEvent e!)
        REM create a new task
        task! = new Task()
        REM open the edit window on that task
        if (#taskProperties! = null()) then
            #taskProperties! = new TaskProperties()
        endif
        #taskProperties!.loadTask(task!)
    methodend


    REM TASK CARD VIEW: different viewing methods
    REM /**
    REM  * - Toggles visibility of #winTaskCardComplete! which contains all complete task child windows
    REM  * - When toggle is off, displays #winTaskCardIncomplete! which contains all incomplete task child windows
    REM  * - Toggles all related classes
    REM  * - Triggered by #btnCompleteView!
    REM  *
    REM  * @param BBjButtonPushEvent e! The BBjButtonPushEvent that causes this method to be executed
    REM  */
    method public void onShowCompletedTasks(BBjButtonPushEvent e!)
        btnShowCompletedTasks! = e!.getControl()
        btnShowCompletedTasks!.toggleClass("icon-completed-selected")
        if (#taskView! = "incomplete") then
            #taskView! = "complete"
        else
            #taskView! = "incomplete"
            #winTaskCardComplete!.setVisible(0)
        endif
    methodend

    REM /**
    REM  * Utility method that sets a CSS custom property given the property and value.
    REM  * It ensures that the CSS property is properly formatted, then builds a CSS
    REM  * string from the iformation and adds it to the DOM, thus overriding any
    REM  * previous setting
    REM  *
    REM  * @param BBjString property!   The property name to be set
    REM  * @param BBjString value!      The value to set the property to
    REM  */
    method public void setCssProperty(BBjString property!, BBjString value!)
        REM Sanitize the property by ensuring that it starts with '--' and changing all spaces to dashes
        if !(property!.startsWith("--")) then property! = "--" + property!
        property! = property!.replaceAll(" ", "-").trim()
        value! = value!.trim()
        if (value!.contains(" ")) then value! = "'" + value! + "'"

        REM Build the CSS string for the root element and append it to the DOM's <body> element
        css! = ":root { " + property! + ": " + value! + "; }"
        #webManager!.injectStyle(css!, 0, "app_custom_css_property")
    methodend

    REM /**
    REM  * Injects the CSS file given from the fileName! into the webManager.
    REM  * Depends on the definitions of #appPath! and #webManager!
    REM  * Sets the name of the CSS file to taskapp_filename_css.
    REM  *
    REM  * @param BBjString fileName!  The name of the CSS file
    REM  */
    method public void injectCSSFile(BBjString fileName!)
        chan = unt
        open(chan,isz=-1) #appPath!+fileName!
        read record(chan,siz=1000000) css$

        #webManager!.injectStyle(css$, 0, "name=taskapp_"+fileName!.toLowerCase().replace(".","_"))
    methodend

    REM /**
    REM  * Returns the collection of Task objects in a JsonArray.  This is used to
    REM  * serialize the tasks so that they can be exported, shared with another app,
    REM  * or saved to disk.
    REM  *
    REM  * @return JsonArray     The tasks collection as a JsonArray
    REM  */
    method protected JsonArray getTasksAsJsonArray()
        declare JsonArray array!
        declare auto BBjString uuid!
        declare auto Task task!

        array! = new JsonArray()
        it! = #tasks!.keySet().iterator()
        while it!.hasNext()
            uuid! = it!.next()
            task! = #tasks!.get(uuid!)
            array!.add(task!.getAsJsonObject())
        wend
        methodret array!
    methodend

    REM /**
    REM  * Callback method for the export button. Exports tasks to a task.json file.
    REM  *
    REM  * @param BBjButtonPushEvent e! The BBjButtonPushEvent that called this method
    REM  */
    method public void onExport(BBjButtonPushEvent e!)
        json! = #getTasksAsJsonArray()
        gson! = new GsonBuilder().setPrettyPrinting().create()

        rem Write the tasks out to the client browser's storage
        jsonString! = gson!.toJson(json!).toString()
        BBjAPI().getThinClient().setUserProperty(BBjThinClient.USER_PROPERTIES_STORAGE, #appName!, jsonString!)

        Utils.consoleLog("Exported " + str(#tasks!.size()) + " tasks to the client browser's storage")
        chan = unt
        f$ = #appPath! + "tasks.json"
        open(chan, isz=-1, mode="O_TRUNC,O_CREATE") f$
            write record(chan) gson!.toJson(json!).toString()
        close(chan)

    methodend

    REM /**
    REM  * Callback for the Import tasks button.  Imports tasks from the tasks.json file in the TaskApp app directory.
    REM  *
    REM  * @param BBjButtonPushEvent e!     BBjButtonPushEvent that invoked this method.
    REM  */
    method public void onImport(BBjButtonPushEvent e!)
        rem Read in the tasks from the client browser's storage
        json$ = BBjAPI().getThinClient().getUserProperty(BBjThinClient.USER_PROPERTIES_STORAGE, #appName!, err=*NEXT)

        rem If there weren't any tasks in user storage, attempt to load them from a file on the server
        if (len(json$) = 0) then
            chan = unt
            f$ = #appPath! + "tasks.json"
            open(chan, isz=-1, err=ERR_MISSING_TASKS_FILE) f$
                read record(chan, siz=-1000000) json$
            close(chan)
            loadedTasksFromFile = 1
            Utils.consoleLog("Loaded " + str(#tasks!.size()) + " tasks from server file")
        else
            Utils.consoleLog("Loaded " + str(#tasks!.size()) + " tasks from browser storage")
        endif

        parser! = new JsonParser()
        json! = parser!.parseString(json$)

        gson! = new GsonBuilder().setPrettyPrinting().create()
        array! = gson!.fromJson(json!, JsonArray.class)
        it! = array!.iterator()

        while(it!.hasNext())
            jsonTask! = it!.next()
            t! = new Task(jsonTask!)
            #addTask(t!)
        wend

        rem If we loaded the tasks from the server file, then write them to browser storage
        if (loadedTasksFromFile) then
            #onExport(null())
        endif
        methodret

        ERR_MISSING_TASKS_FILE:
        rem If the tasks aren't present in browser storage or a server file, then we create sample tasks
        #createSampleTasks(20)
        Utils.consoleLog("created " + str(#tasks!.size()) + " sample tasks")
        #onExport(null())
    methodend

classend


REM BBj USE Statements
use ::Task.bbj::Task
use ::TaskProperties.bbj::TaskProperties
use ::TaskListView.bbj::TaskListView
use ::TaskView.bbj::TaskView
use ::Settings.bbj::Settings
use ::TaskCardView.bbj::TaskCardView
use ::Utils.bbj::Utils

REM Java USE Statements
use java.time.LocalDate
use java.util.TreeMap
use java.util.HashMap
use java.net.URLEncoder
use java.net.URLDecoder

REM Google's Gson for JSON, which is included with BBj
use com.google.gson.Gson;           REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/Gson.html
use com.google.gson.GsonBuilder;    REM https://javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/GsonBuilder.html
use com.google.gson.JsonObject;     REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/JsonObject.html
use com.google.gson.JsonArray;      REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/JsonArray.html
use com.google.gson.JsonParser;     REM https://javadoc.io/static/com.google.code.gson/gson/2.10.1/com.google.gson/com/google/gson/JsonParser.html